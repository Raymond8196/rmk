#![no_std]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

// Include bindgen-generated bindings
// This will be generated by build.rs when compiling for ARM targets
#[cfg(target_arch = "arm")]
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

// Stub definitions for non-ARM targets (documentation, IDE support, cargo check)
#[cfg(not(target_arch = "arm"))]
mod stubs {
    pub type gz_error_t = i32;
    pub const GZ_OK: gz_error_t = 0;
    pub const GZ_ERR_SEND_FAILED: gz_error_t = -1;
    pub const GZ_ERR_RECEIVE_FAILED: gz_error_t = -2;
    pub const GZ_ERR_FRAME_TOO_LARGE: gz_error_t = -3;
    pub const GZ_ERR_NOT_INITIALIZED: gz_error_t = -4;
    pub const GZ_ERR_BUSY: gz_error_t = -5;
    pub const GZ_ERR_INVALID_CONFIG: gz_error_t = -6;
    pub const GZ_ERR_HARDWARE: gz_error_t = -7;

    pub type gz_mode_t = u32;
    pub const GZ_MODE_DEVICE: gz_mode_t = 0;
    pub const GZ_MODE_HOST: gz_mode_t = 1;

    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gz_config_t {
        pub channel: u8,
        pub data_rate: u8,
        pub tx_power: i8,
        pub max_retries: u8,
        pub ack_timeout_us: u16,
        pub base_address: [u8; 4],
        pub address_prefix: u8,
    }

    extern "C" {
        pub fn gz_init(config: *const gz_config_t) -> gz_error_t;
        pub fn gz_set_mode(mode: gz_mode_t) -> gz_error_t;
        pub fn gz_send(data: *const u8, len: u8) -> gz_error_t;
        pub fn gz_recv(out_buf: *mut u8, out_len: *mut u8, max_len: u8) -> gz_error_t;
        pub fn gz_is_ready() -> bool;
        pub fn gz_flush() -> gz_error_t;
        pub fn gz_deinit();
    }
}

#[cfg(not(target_arch = "arm"))]
pub use stubs::*;
